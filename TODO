* long term feature: shared_ptr less locator and resource cache
* custom allocators and EnTT allocator-aware in general (long term feature, I don't actually need it at the moment) - see #22
* debugging tools (#60): the issue online already contains interesting tips on this, look at it
* work stealing job system (see #100) + mt scheduler based on const awareness for types
* meta: sort of meta view based on meta stuff to iterate entities, void * and meta info objects (remove runtime views, welcome reflection)
* add opaque input iterators to views and groups that return tuples <entity, T &...> (proxy), multi-pass guaranteed
* allow to replace std:: with custom implementations
* custom (decoupled) pools ==> N-buffering, shared components, multi-model, hibitsets, and so on
* add examples (and credits) from @alanjfs :)
* static reflection, hint: template<> meta_type_t<Type>: meta_descriptor<name, func..., props..., etc...> (see #342)
* can we write a bool conv func for entt::entity that silently compares it to null?
* is it possible to make 0 the entity null?
* update documentation for meta, it contains less than half of the actual feature

Next:
* make it easier to hook into the type system and describe how to do that to eg auto-generate meta types on first use
* review multi component views to reduce instantiations once empty types are gone...
* add observer functions aside observer class

* WIP:
 - introduce the component iterators for non-contiguous collections of entities (multi component views, observers, user defined collections)

* WIP: snapshot rework
 - snapshot: support for range-based archives
 - update documentation to describe alternatives

* WIP:
 - meta: update doc
 - static constexpr -> inline constexpr
 - test: meta type seq/assoc traits, containers
 - document meta type traits
 - remove internal::find_if


struct meta_view_node {
    using size_type = std::size_t;
    meta_type_node *(* const key_type)() ENTT_NOEXCEPT;
    meta_type_node *(* const value_type)() ENTT_NOEXCEPT;
    void(* const next)(meta_handle) ENTT_NOEXCEPT;
    void(* const prev)(meta_handle) ENTT_NOEXCEPT;
    bool(* const empty)(meta_handle) ENTT_NOEXCEPT;
    void(* const clear)(meta_handle);
    size_type(* const size)(meta_handle) ENTT_NOEXCEPT;
    meta_any(* const begin)(meta_handle) ENTT_NOEXCEPT;
    meta_any(* const end)(meta_handle) ENTT_NOEXCEPT;
    meta_any(* const erase)(meta_handle, meta_handle);
    meta_any(* const insert)(meta_handle, meta_any, meta_any);
    bool(* const set)(meta_handle, meta_any, meta_any);
    meta_any(* const get)(meta_handle, meta_any);
};

static meta_view_node * view() ENTT_NOEXCEPT {
    if constexpr(is_container_v<Type>) {
        static meta_view_node node{
            []() {
                if constexpr(is_sequence_container_v<Type>) {
                    return &internal::meta_node<typename Type::size_type>::resolve;
                } else {
                    return &internal::meta_node<typename Type::key_type>::resolve;
                }
            },
            &internal::meta_node<typename Type::value_type>::resolve,
            nullptr, // void(* const next)(meta_handle) ENTT_NOEXCEPT;
            nullptr, // void(* const prev)(meta_handle) ENTT_NOEXCEPT;
            nullptr, // bool(* const empty)(meta_handle) ENTT_NOEXCEPT;
            nullptr, // void(* const clear)(meta_handle);
            [](meta_handle instance) -> typename meta_view_node::size_type {
                return (*instance).cast<Type>().size();
            }, // size_type(* const size)(meta_handle) ENTT_NOEXCEPT;
            nullptr, // meta_any(* const begin)(meta_handle) ENTT_NOEXCEPT;
            nullptr, // meta_any(* const end)(meta_handle) ENTT_NOEXCEPT;
            nullptr, // meta_any(* const erase)(meta_handle, meta_handle);
            nullptr, // meta_any(* const insert)(meta_handle, meta_any, meta_any);
            nullptr, // bool(* const set)(meta_handle, meta_any, meta_any);
            nullptr // meta_any(* const get)(meta_handle, meta_any);
        };

        return &node;
    } else {
        return nullptr;
    }
}
